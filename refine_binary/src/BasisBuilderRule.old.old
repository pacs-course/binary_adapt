#include "BasisBuilderRule.h"

using namespace std;

namespace FiniteElements
{
	////TODO: verify if it is optimizable
	//it follows the alghoritm proposed in "Modellistica numerica per problemi differenziali", A.Quarteroni, 5a ed., p.234
	vector<Polinomial<1>> LegendreBuilder::operator() (size_t degree)
	{
		vector<Polinomial<1> > result;
		Polinomial<1> x(1,1);
		x[0] = 0;
		Polinomial<1> first (0, sqrt(0.5));

		result.push_back(first);
		if (degree)
		{
			Polinomial<1> second = x * sqrt(1.5);

			result.push_back(second);
			Polinomial<1> before(second);
			Polinomial<1> beforeBefore(first);
			Polinomial<1> newPol;

			//at each step I calculate di k+1 degree polinomial
			size_t k (1);
			while (k < degree)
			{
#ifdef MYDEBUG
				cout << "fattori: " << endl; before.print(); beforeBefore.print();
				cout << "I fattori hanno grado >>>>> " << before.degree() << ",	" << beforeBefore.degree() << endl;
#endif //MYDEBUG
				double k_d = static_cast<double>(k);

				//L_(k + 1) computation
				newPol =  x * (2 * k_d + 1);
#ifdef MYDEBUG
				cout << "Coefficienti nuovo termine:	";
				newPol.print();
#endif //MYDEBUG

				newPol *= (before / sqrt(k_d + 0.5));

#ifdef MYDEBUG
				cout << "Coefficienti nuovo termine:	";
				newPol.print();
#endif //MYDEBUG

				newPol -= (beforeBefore / sqrt(k_d - 0.5)) * k_d;

				newPol /= (k_d + 1);

				//normalization for the orthonormality
				newPol *= sqrt(k_d + 1.5);

#ifdef MYDEBUG
				cout << "Coefficienti nuovo termine:	";
				newPol.print();
				cout << "Grado del nuovo termine >>>>>> " << newPol.degree() << endl; 
#endif //MYDEBUG

				result.push_back(newPol);
				beforeBefore = before;
				before = newPol;
				++k;
			}
		}
		return result;
	};

	vector<Polinomial<1>> TrivialBuilder::operator() (size_t degree)
	{	
		vector<Polinomial<1> > result;

		Polinomial<1> first (0, 1);
		result.push_back(first);
		
		if (degree)
		{
			Polinomial<1> x (1,1);
			x[0]=0;

			result.push_back(x);
			Polinomial<1>* before = &x;
			Polinomial<1> newPol;
			for (size_t k (2); k <= degree; ++k)
			{	
				newPol =  x * (*before);
				result.push_back(newPol);
				before = &newPol;
			}
		}
		return result;
	};

	InvalidBuilder::InvalidBuilder()
	{
		throw invalid_argument("Trying to construct a builder object for an INVALID type basis");
	};

	vector<Polinomial<1>> InvalidBuilder::operator() (size_t degree)
	{
		/*to avoid warning by the compiler*/
		(void)degree;
		return vector<Polinomial<1>>();
	};

} //namespace FiniteElements
