#ifndef __FINITE_F_H
#define __FINITE_F_H

#include "Basis.h"
#include <memory> //unique_ptr

using namespace std;
using namespace Geometry;

namespace BinaryTree
{
	template <size_t DIM>
		class FiniteFunction
		{
			public:
				FiniteFunction(PolinomialBasis<DIM>* basis_ptr) : _basisfunctions(basis_ptr)
				{
					_coeff.resize(_basisfunctions->size());
				};

				FiniteFunction(PolinomialBasis<DIM>* basis_ptr, const vector<double>& coeff) :	_basisfunctions(basis_ptr),
																															_coeff(coeff)
				{			};			

				double operator() (const Point<DIM>& point)
				{
					double result(0);
					size_t i(0);
					vector<double> basisEvaluation = _basisfunctions->evaluateBasis(point);

					//TODO: optimizable: use eigen dot product
					for (auto c : _coeff)
					{
						result += c * basisEvaluation[i++];
					}
					return result;
				};

				double& operator[] (size_t ind)
				{
					return _coeff[ind];
				};

			protected:
				vector<double> _coeff;
				//maybe shared_ptr could be safer
				unique_ptr<PolinomialBasis<DIM>> _basisfunctions;
		};

};//namespace BinaryTree
#endif //__FINITE_F_H
