#ifndef __ELEMENT_H
#define __ELEMENT_H

#include "Maps.h"
#include "ReferenceElement.h"

using namespace std;
using namespace Maps;
using namespace Geometry;

namespace BinaryTree
{

	template <size_t DIM>
		class Element : public virtual AbstractElement<DIM>
		{
			public:
				virtual ~Element() = 0;

				Element(libMesh::ElemType type)
				{
					//TODO 
				};

				//TODO: verify if it's convenient to store the quadrature nodes and weights as an attribute of the element
				virtual QuadPointVec<DIM> getQuadPoints()const
				{
					return _refElement.getMappedPoints(*_map);
				};

				virtual QuadWeightVec getQuadWeights()const
				{
					return _refElement.getMappedWeights(*_map);
				};

			protected:
				shared_ptr<AffineMap<DIM>> _map;
				StdElement<DIM>& _refElement;
		};

	template <size_t DIM>
		class	FElement : public Element<DIM>, public AbstractFElement<DIM>
		{
			public:
				FElement(libMesh::ElemType type, string basisID)
				{
					//TODO
				};

				virtual ~FElement() = 0;

				virtual FiniteFunction<DIM> interpolate(size_t p_degree, const function<double(Point<DIM>)>& f)
				{
					return _stdFElement.mappedInterpolation(p_degree, f, *(this->_map));
				};
				//TODO: optimize storing already evaluated points
				virtual double evaluateBasisFunction (size_t ind, const Point<DIM>& point)const
				{
					return _stdFElement.evaluateBasisFunction(ind, (this->_map).computeInverse(point));
				};

				virtual vector<double> evaluateBasis (const Point<DIM>& point)const
				{
					return _stdFElement.evaluateBasis ( (this->_map).computeInverse(point) );
				};

				virtual size_t	basisSize()const
				{
					return _stdFElement.basisSize();
				};

			protected:
				StdFElement<DIM>& _stdFElement;
		};


};//namespace BinaryTree

#endif //__ELEMENT_H
