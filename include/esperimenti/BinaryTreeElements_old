#ifndef __BINARY_ELEMENT_H
#define __BINARY_ELEMENT_H

#include "Point.h"
#include "Maps.h"
#include "Quadrature.h"

#include <face_tri3.h> //libMesh::Tri3
#include <edge_edge2.h> //libMesh::Edge2

#include <memory> //std::shared_ptr
#include <functional> //std::function

namespace BinaryTree
{
	using namespace std;
	using namespace Quadrature;

	using LibmeshInterval = libMesh::Edge2;
	using LibmeshTriangle = libMesh::Tri3;

///*
//	Type used to store quadrature nodes: matrix columns are points in R^ROW 
//	rows will depend on the dimension of the problem
//	cols on the order of the quadrature rule
//*/
//		template <size_t ROW>
//			using QuadMatrix = Eigen::Matrix <double, static_cast<int>(ROW), Dynamic>;



/*
	Abstract class: it implements all the (geometry independent) stuff
	that an element of the binary tree must have to be used for the
	binary-tree hp-adaptivity algorithm proposed in Binev paper
*/

	//TODO: verify if it's correct to derive FElement from BinTreeElement or if it's better the inverse
	class BinTreeElement
	{
		public:
			BinTreeElement(){};
			double projectionError() const
			{
				return _projectionError;
			};

			
		protected:
			void projectionError(const double& val)
			{
				_projectionError = val;
			};

		private:
			double _projectionError;
			//TODO: attributes needed by the algorithm
	};


	template <size_t DIM>
		class Element : BinTreeElement
		{
			public:
				Element(libmesh::ElemType type)
				{
					//TODO 
				};

				//TODO: verify if it's convenient to store the quadrature nodes and weights as an attribute of the element
				virtual QuadPointVec<DIM> getQuadPoints()
				{
					vector<libMesh::Point> stdpoints = _quadratureRule->get_points();
					QuadPointVec<DIM> result;

					for (auto p : stdpoints)
					{
						//it uses the implicit cast from libMesh::Point to Point<DIM>
						QuadratureNode qp(p, _map);
						result.push_back(qp);
					}
					return result;
				};

				virtual QuadVec getQuadWeights()
				{
					vector<libMesh::Real> stdweights = _quadratureRule->get_weights();
					QuadWeightVec result(stdweights.size());

				//it uses the fact that being the map affine implies that the jacobian is constant
					size_t i(0);
				//TODO verify the conversion from libMesh::Real to double
					for (auto w : stdweights)
						result(i++) = w * _map.Jacobian();

					return result;
				};

			protected:
				//TODO: the init method of Qbase is static: what if I want to change quadrule at runtime?
				shared_ptr<libmesh::Qbase> _quadratureRule;
				unique_ptr<AffineMap<DIM>> _map;

				libmesh::ElemType _elemType;
		};
	
	template <size_t DIM>
		class	FElement : public Element<DIM>
		{
			public:
				FElement(libmesh::ElemType type, std::string basisID)
				{
					//TODO
				};

				FiniteFunction<DIM> interpolate(const std::function<double(Point<DIM>)>& f, size_t p_degree)
				{
					LocalBasis<DIM> b(*_basis, &_map);
					FiniteFunction<DIM> projection(b);
					size_t i(0);
					for(auto psi : _basis)
					{
						projection[i++] = L2prod(f, psi); 
					};
					return projection;
				};

				template <typename F1, typename F2>
					double L2prod (F1 fun1, F2 fun2)
					{
						return integrate(*this, [&&](const Point<DIM>& p){return (fun1(p)*fun2(p))^2;});
					};

			protected:
				std::string _basisID;
				//SOMETHING MISSING: SOMEHOW I NEED TO INTRODUCE A CONNECTION BETWEEN THE GEOMETRY AND THE ELEMENT BASIS
				shared_ptr<PolinomialBasis<DIM>> _basis;
		};

	/*
		It decorates creating a connection between the generic PolinomialBasis (build on the reference ipercube) and the local (of any shape) domain
		It is needed to map backward the evaluation points of basis functions
	*/
	template <size_t DIM>
		class LocalBasis : PolinomialBasis<DIM>
		{
			public:
				LocalBasis (const PolinomialBasis<DIM>& stdbasis, const Map<DIM>* domainMap) :	_stdbasis(stdbasis),
																															_domainMap(domainMap)
																															{
																															};
				
				LocalBasis (const PolinomialBasis<DIM>& stdbasis,
								const Map<DIM>& domainMap,
								PoliBaseBuilderRule_ptr rule,
								size_t degree								) : LocalBasis(stdbasis, domainMap) 
				{
					//TODO
				};


				virtual double evaluatefunction (size_t index, const Point<DIM>& point)const override
				{
					//TODO: check that stdpoint is effectively the point on which the basis function have to be evaluated
					//IDEA: insert in the basis a stddomain flag
					Point<DIM> stdpoint = _domainMap.computeInverse(point);
					return _stdBasis.evaluate(index, stdpoint);
				};

				virtual vector<double> evaluatebasis(const Point<DIM>& point)const override
				{
					vector<double> result;
					size_t i(0);
					for (auto iter : (*this))
						result.push_back(evaluatefunction(i, point);

					return result;
				};

			protected:
				const PolinomialBasis<DIM>& _stdBasis;
				const shared_ptr<Map<DIM>>	 _domainMap;
		}

	template <size_t DIM>
		class FiniteFunction
		{
			FiniteFunction(shared_ptr<PolinomialBasis<DIM>> basis) : _basisfunctions(basis)
			{
				_coeff.resize(_basisfunctions->size());
			};

			double operator() (const Point<DIM>& point)
			{
				double result(0);
				size_t i(0);
				for (auto c : _coeff)
				{
					result += c * _basisfunctions->evaluate(i++, point);
				}
				return result;
			};

			double& operator[] (size_t ind)
			{
				return _coeff[ind];
			};

			protected:
				vector<double> _coeff;
				shared_ptr<LocalBasis<DIM>> _basisfunctions;
		};

	

	//TODO: check if the virtual inheritance could be dangerous in this case
	class Interval : public LibmeshInterval, virtual FElement<1>
	{
		public:

		protected:

	};

	
	class Triangle : public LibmeshTriangle, virtual FElement<2>
	{
		public:

		protected:

	};


} //namespace BinaryTree

#endif //__BINARY_ELEMENT_H
